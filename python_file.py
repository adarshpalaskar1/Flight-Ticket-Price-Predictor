# -*- coding: utf-8 -*-
"""Bonus_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16K-8XUv9yB0MMaRpSsmWsEQy_2wIo0OV
"""

import pandas as pd
import numpy as np

df = pd.read_excel(r"/content/Dataset.xlsx")

df

print(df.shape)

df.isnull().sum()

# dropping the rows having NaN values
df = df.dropna()
 
# To reset the indices
df = df.reset_index(drop = True)
print(df.shape)

df.describe(include = ['O'])

from datetime import date
import calendar

df["Journey_day"] = pd.to_datetime(df["Date_of_Journey"], format="%d/%m/%Y").dt.day
df["Journey_month"] = pd.to_datetime(df["Date_of_Journey"], format = "%d/%m/%Y").dt.month
df["Journey_year"] = pd.to_datetime(df["Date_of_Journey"], format = "%d/%m/%Y").dt.year
df.head()

df['Journey_year'].unique()
# Since the dataset contains information for only one year(2019), we do not need
# the 'Journey_year' column.

# Drop the unnecessary column
df = df.drop(['Journey_year'], axis = 1)

"""Ticket prices may also depend whether the flight operates during a weekday or weekends, since the costs during rush days could be higher."""

df["Weekday"] = pd.to_datetime(df["Date_of_Journey"], format = "%d/%m/%Y").dt.strftime('%A')

df["Month"] = pd.to_datetime(df["Date_of_Journey"], format = "%d/%m/%Y").dt.strftime('%B')

df

"""Flight ticket prices may also depend on during what time of the day the flight departs and arrives at the destination. Therefore, we will will extract the different parts of the day
from the departure and arrival times:
"""

def Dayparting(X):
    
    if int(X[:2]) >= 20 or int(X[:2]) < 4:
        return 'Night'
    elif int(X[:2]) >= 4 and int(X[:2]) < 12:
        return 'Morning'
    elif int(X[:2]) >= 12 and int(X[:2]) < 16:
        return 'Afternoon'
    elif int(X[:2]) >= 16 and int(X[:2]) < 20:
        return 'evening'

df['Dayparting_departure'] = df['Dep_Time'].apply(Dayparting)
df['Dayparting_arrival'] = df['Arrival_Time'].apply(Dayparting)
df

"""There is a steep variation in prices, especially during the period of major holidays since these are the peak periods of operation during the whole year."""

import holidays

for date in holidays.India(years = 2019).items():
    print(date)

ind_holidays=holidays.India(years = 2019) 
ind_holidays.append({'7-10-2019':'Dasehra'})
ind_holidays.append({'8-10-2019':'Dasehra'})
ind_holidays.append({'9-10-2019':'Dasehra'})

ind_holidays.append({'13-01-2019':'Makar Sankranti / Pongal'})
ind_holidays.append({'15-01-2019':'Makar Sankranti / Pongal'})

ind_holidays.append({'20-03-2019':'Holi'})
ind_holidays.append({'21-03-2019':'Holi'})
ind_holidays.append({'22-03-2019':'Holi'})

ind_holidays.append({'27-10-2019':'Diwali'})
ind_holidays.append({'28-10-2019':'Diwali'})
ind_holidays.append({'29-10-2019':'Diwali'})
ind_holidays.append({'30-10-2019':'Diwali'})
ind_holidays.append({'31-10-2019':'Diwali'})

ind_holidays.append({'31-12-2019':'NewYear'})

ind_holidays.append({'24-12-2019':'Christmas'})
ind_holidays.append({'26-12-2019':'Christmas'})



India_Holidays = []

for date in  ind_holidays.items():
    India_Holidays.append(str(date[0]))

for date in India_Holidays:
    print(date)

for i in range(len(India_Holidays)):
    India_Holidays[i] = India_Holidays[i].replace("-","/")

print(India_Holidays)

India_Holidays = ['14/01/2019', '26/01/2019', '15/08/2019', '2/10/2019', '1/05/2019', '25/12/2019', '10/07/2019', '10/08/2019',
                  '02/10/2019', '01/05/2019',
                  '10/09/2019', '13/01/2019', '15/01/2019', '20/03/2019', '21/03/2019', '22/03/2019', '27/10/2019', '28/10/2019',
                  '29/10/2019', '30/10/2019', '31/10/2019', '31/12/2019', '24/12/2019', '26/12/2019',
                  '9/03/2019','6/03/2019','1/03/2019',
                  '09/03/2019','06/03/2019','01/03/2019']

df['Date_of_Journey'][0]

df['Is_Holiday'] = ['Yes' if str(val).split()[0] in India_Holidays else 'No' for val in df['Date_of_Journey'] ]

df.head()

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rcParams

rcParams['figure.figsize'] = 32,8

ax = sns.violinplot(x="Airline", y="Price", data=df, palatte = 'bright')

"""Inorder to observe the variations clearly, we will remove the flights
corresponding to Jet Airways Business class since they are outliers in the data.
"""

df_without_businessclass = df

df_without_businessclass.drop(df_without_businessclass.index[df_without_businessclass['Airline'] == 'Jet Airways Business'], inplace=True)

rcParams['figure.figsize'] = 15,8

ax = sns.barplot(x="Dayparting_departure", y="Price", hue="Airline",
                 data=df_without_businessclass)

rcParams['figure.figsize'] = 15,8

ax = sns.barplot(x="Dayparting_arrival", y="Price", hue="Airline",
                 data=df_without_businessclass)

rcParams['figure.figsize'] = 15,8

ax = sns.barplot(x="Weekday", y="Price", hue="Airline",
                 data=df_without_businessclass)

rcParams['figure.figsize'] = 15,8

ax = sns.barplot(x="Is_Holiday", y="Price", hue="Airline",
                 data=df_without_businessclass)

(df['Is_Holiday'] == 'Yes').sum()

rcParams['figure.figsize'] = 15,8

ax = sns.barplot(x="Month", y="Price", hue="Airline",
                 data=df_without_businessclass)

"""Flight prices also depend on number of stops"""

def number_of_stops(value):
    if value == '4 stops':
        return 4
    elif value == '3 stops':
        return 3
    elif value == '2 stops':
        return 2
    elif value == '1 stop':
        return 1
    elif value == 'non-stop':
        return 0
    else:
        return 0

df['Total_Stops'] = df['Total_Stops'].map(number_of_stops)

df_without_businessclass = df

df_without_businessclass.drop(df_without_businessclass.index[df_without_businessclass['Airline'] == 'Jet Airways Business'], inplace=True)

df

rcParams['figure.figsize'] = 15,8

ax = sns.barplot(x="Total_Stops", y="Price", hue="Airline",
                 data=df_without_businessclass)

"""Variation of prices according to routes:"""

df_indigo = df[df['Airline'] == 'IndiGo']
df_indigo

rcParams['figure.figsize'] = 30,10

ax = sns.barplot(x="Airline", y="Price", hue="Route",
                 data=df_indigo)

df_jet_airways = df[df['Airline'] == 'Jet Airways']


rcParams['figure.figsize'] = 30,10

ax = sns.barplot(x="Airline", y="Price", hue="Route",
                 data=df_jet_airways)

"""Thus we observe that there is a huge variation in flight prices depending on the route which the flight takes.

Converting flight duration to seconds:
"""

import re

def convert_into_seconds(X):
    
    a = [int(s) for s in re.findall(r'-?\d+\.?\d*', X)]
    if len(a) == 2:
        hr = a[0] * 3600
        min = a[1] * 60
    else:
        hr = a[0] * 3600
        min = 0   
    total = hr + min
    return total

df['Duration(sec)'] = df['Duration'].map(convert_into_seconds)

"""Dropping duplicate rows:"""

df = df.drop_duplicates()
df.shape

"""Handling typos:"""

df['Additional_Info'].unique()

# Since 'No Info' and 'No info' are same:
df['Additional_Info'].replace('No Info', 'No info', inplace = True)

"""Since all the categorical features are ordinal type, we will create dummy variables for each such attribute:"""

df = pd.get_dummies(df, columns = ['Airline', 'Source', 'Destination', 'Additional_Info',
                                   'Weekday','Month', 'Dayparting_departure','Dayparting_arrival',
                                   'Is_Holiday','Route'])

pd.set_option('display.max_columns',1000)
df

df.drop(['Date_of_Journey', 'Dep_Time', 'Arrival_Time', 'Duration'], axis = 1, inplace = True)

df

"""Splitting the dataset:"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

from sklearn.metrics import mean_squared_error as mse
from sklearn.metrics import r2_score

from math import sqrt

from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import RandomizedSearchCV

from sklearn.neighbors import KNeighborsRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from xgboost import XGBRegressor
from sklearn.ensemble import RandomForestRegressor, AdaBoostRegressor, GradientBoostingRegressor

X = df.drop('Price', axis=1)
y = df['Price']

s = StandardScaler()
X = s.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state=42)

X_train.shape, X_test.shape, y_train.shape, y_test.shape

"""Testing on different ML models:

1. Decision Tree Regressor:
"""

depth  = list(range(2,40))

param_grid = dict(max_depth =depth)

model1 = GridSearchCV(DecisionTreeRegressor(),param_grid,cv = 5)
model1.fit(X_train,y_train)

y_train_pred = model1.predict(X_train) 
y_test_pred = model1.predict(X_test) 

print("Train Results for Decision Tree Regressor :")
train_mse1 = sqrt(mse(y_train.values, y_train_pred))
train_r2_1 = r2_score(y_train.values, y_train_pred)

print("Root mean squared error : ", sqrt(mse(y_train.values, y_train_pred)))
print("R2 Score : ", r2_score(y_train.values, y_train_pred))


print('------------------------------------------------------------------')


print("Test Results for Decision Tree Regressor :")
test_mse1 = sqrt(mse(y_test, y_test_pred))
test_r2_1 = r2_score(y_test, y_test_pred)

print("Root mean squared error : ", sqrt(mse(y_test, y_test_pred)))
print("R2 Score : ", r2_score(y_test, y_test_pred))

"""2. Gradient Boosting Regressor"""

tuned_params = {
            'learning_rate' : [0.5, 0.8, 0.1, 0.20, 0.25, 0.30],
            'n_estimators' : [300, 500, 700, 1000, 2100],
            'criterion' : ['friedman_mse', 'mse']}

model2 = RandomizedSearchCV(GradientBoostingRegressor(), tuned_params, n_iter=20, cv=5)
model2.fit(X_train, y_train)

y_train_pred = model2.predict(X_train) 
y_test_pred = model2.predict(X_test) 

print("Train Results for Gradient Boosting Regressor :")

train_mse2 = sqrt(mse(y_train.values, y_train_pred))
train_r2_2 = r2_score(y_train.values, y_train_pred)
print("Root mean squared error : ", sqrt(mse(y_train.values, y_train_pred)))
print("R2 Score : ", r2_score(y_train.values, y_train_pred))


print('------------------------------------------------------------------')


print("Test Results for Gradient Boosting Regressor :")

test_mse2 = sqrt(mse(y_test, y_test_pred))
test_r2_2 = r2_score(y_test, y_test_pred)
print("Root mean squared error : ", sqrt(mse(y_test, y_test_pred)))
print("R2 Score : ", r2_score(y_test, y_test_pred))

"""3. Random Forest Regressor:"""

tuned_params = {'n_estimators' : [300, 500, 700, 1000, 2100],
            'max_depth' : [3, 5, 7, 9, 11, 13, 15],
            'max_features' : ["auto", "sqrt", "log2"],
            'min_samples_split' : [2, 4, 6, 8]}

model3 = RandomizedSearchCV(RandomForestRegressor(), tuned_params, n_iter = 20, scoring = 'neg_mean_absolute_error', cv = 5)
model3.fit(X_train, y_train)

y_train_pred = model3.predict(X_train) 
y_test_pred = model3.predict(X_test) 

print("Train Results for Random Forest Regressor :")

train_mse3 = sqrt(mse(y_train.values, y_train_pred))
train_r2_3 = r2_score(y_train.values, y_train_pred)
print("Root mean squared error : ", sqrt(mse(y_train.values, y_train_pred)))
print("R2 Score : ", r2_score(y_train.values, y_train_pred))


print('------------------------------------------------------------------')


print("Test Results for Random Forest Regressor :")

test_mse3 = sqrt(mse(y_test, y_test_pred))
test_r2_3 = r2_score(y_test, y_test_pred)
print("Root mean squared error : ", sqrt(mse(y_test, y_test_pred)))
print("R2 Score : ", r2_score(y_test, y_test_pred))

"""4. AdaBoost Regressor:"""

tuned_params = {'n_estimators' : [100, 300, 500, 700, 1000, 1500, 2100],
                'learning_rate' : [0.10, 0.20, 0.25, 0.30, 0.50, 0.80]}

model4 = RandomizedSearchCV(AdaBoostRegressor(), tuned_params, n_iter=20, cv=5)
model4.fit(X_train, y_train)

y_train_pred = model4.predict(X_train) 
y_test_pred = model4.predict(X_test) 

print("Train Results for AdaBoost Regressor :")

train_mse4 = sqrt(mse(y_train.values, y_train_pred))
train_r2_4 = r2_score(y_train.values, y_train_pred)
print("Root mean squared error : ", sqrt(mse(y_train.values, y_train_pred)))
print("R2 Score : ", r2_score(y_train.values, y_train_pred))

print('------------------------------------------------------------------')

print("Test Results for AdaBoost Regressor :")

test_mse4 = sqrt(mse(y_test, y_test_pred))
test_r2_4 = r2_score(y_test, y_test_pred)
print("Root mean squared error : ", sqrt(mse(y_test, y_test_pred)))
print("R2 Score : ", r2_score(y_test, y_test_pred))

"""5. XGBoost Regressor:"""

tuned_params = {'learning_rate' : [0.5, 0.8, 0.1, 0.20, 0.25, 0.30],
            'max_depth' : [3, 5, 7, 9, 11, 13, 15],
            'gamma' : [0.1,0.2, 0.3, 0.4, 0.5],
            'min_child_weight' : [1, 3, 5, 7, 9],
            'colsample_bytree' : [0.5, 0.8, 0.1, 0.20, 0.25, 0.30]}

model5 = RandomizedSearchCV(XGBRegressor(), tuned_params, n_iter=20, cv=5)
model5.fit(X_train, y_train)

y_train_pred = model5.predict(X_train) 
y_test_pred = model5.predict(X_test) 

print("Train Results for XGBoost Regressor :")

train_mse5 = sqrt(mse(y_train.values, y_train_pred))
train_r2_5 = r2_score(y_train.values, y_train_pred)
print("Root mean squared error : ", sqrt(mse(y_train.values, y_train_pred)))
print("R2 Score : ", r2_score(y_train.values, y_train_pred))


print('------------------------------------------------------------------')


print("Test Results for XGBoost Regressor :")

test_mse5 = sqrt(mse(y_test, y_test_pred))
test_r2_5 = r2_score(y_test, y_test_pred)
print("Root mean squared error : ", sqrt(mse(y_test, y_test_pred)))
print("R2 Score : ", r2_score(y_test, y_test_pred))

Models = ['Decision Tree Regressor', 'Gradient Boosting Regressor', 'Random Forest Regressor', 
          'AdaBoost Regressor', 'XGBoost Regressor' ]

train_mse = [train_mse1, train_mse2, train_mse3, train_mse4, train_mse5 ]

train_r2 = [train_r2_1, train_r2_2, train_r2_3, train_r2_4, train_r2_5]

test_mse = [test_mse1, test_mse2, test_mse3, test_mse4, test_mse5]

test_r2 = [test_r2_1, test_r2_2, test_r2_3, test_r2_4, test_r2_5]

"""Comparing models using root mean squared errors:"""

ax = sns.barplot(x = Models, y = train_mse)

ax = sns.barplot(x = Models, y = test_mse)

"""Comparing Models using R2 scores:"""

ax = sns.barplot(x = Models, y = train_r2)

ax = sns.barplot(x = Models, y = test_r2)







